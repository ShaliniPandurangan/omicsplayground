##
## This file is part of the Omics Playground project.
## Copyright (c) 2018-2023 BigOmics Analytics SA. All rights reserved.
##


ConnectivityBoard <- function(id, pgx, getPgxDir) {
  moduleServer(id, function(input, output, session) {

    ns <- session$ns ## NAMESPACE
    fullH <- 750 # row height of panel
    tabH <- "70vh"

    infotext <- strwrap(
      "The <strong>Experiment connectivity</strong> module enables users to
      compare their data to other datasets. For the selected contrast, this
      module provides pairwise correlation plots and/or enrichment plots with
      signatures from other data sets. The <strong>Connectivity map</strong>
      shows the similarity of the contrasts profiles as a t-SNE plot.<br><br>
      <br><br><center><iframe width='500' height='333'
      src='https://www.youtube.com/embed/watch?v=qCNcWRKj03w&list=PLxQDY_RmvM2JYPjdJnyLUpOStnXkWTSQ-&index=5'
      frameborder='0' allow='accelerometer; autoplay; encrypted-media;
      gyroscope; picture-in-picture' allowfullscreen></iframe></center>"
    )
    
    ## ================================================================================
    ## ======================= OBSERVE FUNCTIONS ======================================
    ## ================================================================================

    shiny::observeEvent(input$info, {
      shiny::showModal(shiny::modalDialog(
        title = shiny::HTML("<strong>Connectivity Analysis Board</strong>"),
        shiny::HTML(infotext),
        easyClose = TRUE, size = "l"
      ))
    })

    ## update choices upon change of data set
    shiny::observe({
      shiny::req(pgx, pgx$connectivity)
      comparisons <- colnames(pgx$model.parameters$contr.matrix)
      comparisons <- sort(comparisons)
      shiny::updateSelectInput(session, "contrast",
        choices = comparisons,
        selected = head(comparisons, 1)
      )
      
      sigdb <- c("A", "B", "C")
      sigdb <- dir(SIGDB.DIR, pattern = "sigdb-.*h5$")
      ##sigdb1 <- file.path(getPgxDir(),"datasets-sigdb.h5")
      sigdb1 <- "datasets-sigdb.h5"
      ##if(file.exists(sigdb1)) sigdb <- c(sigdb, sigdb1)
      sigdb <- c(sigdb, sigdb1)      
      computed.sigdb <- names(pgx$connectivity) ## only precomputed inside PGX object??
      ## sigdb <- sort(intersect(sigdb, computed.sigdb))
      sel <- sigdb[1]
      shiny::updateSelectInput(session, "sigdb", choices = sigdb, selected = sel)
    })

    shiny::observe({
      ## reset CMap threshold zero/max
      res <- getConnectivityScores()
      shiny::req(res)
      max <- round(0.999 * max(abs(res$score), na.rm = TRUE), digits = 1)
      max <- round(0.999 * tail(sort(abs(res$score)), 10)[1], digits = 1)
      shiny::updateSliderInput(session, "scorethreshold", value = 0, max = max)
    })

    ## update choices upon change of chosen contrast
    shiny::observeEvent(input$contrast, {
      shiny::req(pgx, pgx$connectivity)

      ## reset CMap threshold zero/max
      res <- getConnectivityScores() ## result gets cached
      shiny::req(res)
      max <- round(0.999 * max(abs(res$score), na.rm = TRUE), digits = 1)
      shiny::updateSliderInput(session, "scorethreshold", value = 0, max = max)
    })

    getCurrentContrast <- shiny::reactive({
      shiny::req(pgx, pgx$connectivity, input$contrast)
      ct <- input$contrast
      fc <- pgx$gx.meta$meta[[ct]]$meta.fx
      names(fc) <- rownames(pgx$gx.meta$meta[[ct]])
      gs <- pgx$gset.meta$meta[[ct]]$meta.fx
      names(gs) <- rownames(pgx$gset.meta$meta[[ct]])
      names(fc) <- toupper(names(fc)) ## de-MOUSE
      list(name = ct, fc = fc, gs = gs)
    })

    ## ================================================================================
    ## ========================= REACTIVE FUNCTIONS ===================================
    ## ================================================================================
    cumEnrichmentTable <- shiny::reactive({
      sigdb <- input$sigdb
      shiny::req(sigdb, pgx, pgx$connectivity)
      if (!grepl(".h5$", sigdb)) {
        return(NULL)
      }

      df <- getConnectivityScores()
      if (is.null(df)) {
        return(NULL)
      }
      ii <- connectivityScoreTable$rows_all()
      shiny::req(ii)

      sel <- head(df$pathway[ii], 10)
      sigdb <- input$sigdb
      F <- getEnrichmentMatrix(sigdb, select = sel)
      if (is.null(F)) {
        return(NULL)
      }

      ## multiply with sign of enrichment
      rho1 <- df$rho[match(colnames(F), df$pathway)]
      F <- t(t(F) * sign(rho1))

      F <- F[order(-rowMeans(F**2)), , drop = FALSE]

      ## add current contrast
      ct <- getCurrentContrast()
      gx <- ct$gs[match(rownames(F), names(ct$gs))]
      names(gx) <- rownames(F)
      gx[is.na(gx)] <- 0
      F <- cbind(gx, F)
      colnames(F)[1] <- ct$name

      F
    })

    getConnectivityFilename <- function(sigdb) {
      db1 <- file.path(SIGDB.DIR, sigdb)
      db2 <- file.path(getPgxDir(), sigdb)
      if( file.exists(db1)) return(db1)
      if( file.exists(db2)) return(db2)
      return(NULL)
    }

    #' Get the path/folder to the signature database file. 
    #'
    #' @param sigdb signature h5 file  
    getConnectivityPath <- function(sigdb) {
      db1 <- file.path(SIGDB.DIR, sigdb)
      db2 <- file.path(getPgxDir(), sigdb)
      if( file.exists(db1)) return(SIGDB.DIR)
      if( file.exists(db2)) return(getPgxDir())
      return(NULL)
    }

    getConnectivityContrasts <- function(sigdb) {
      if (length(sigdb) == 0 || is.null(sigdb) || sigdb == "") {
        return(NULL)
      }
      cpath <- getConnectivityPath(sigdb)
      playbase::sigdb.getConnectivityContrasts(sigdb, path=cpath)
    }

    getConnectivityMatrix <- function(sigdb, select = NULL, genes = NULL) {
      cpath <- getConnectivityPath(sigdb)
      playbase::sigdb.getConnectivityMatrix(sigdb, select=select, genes=genes, path=cpath) 
    }

    getEnrichmentMatrix <- function(sigdb, select = NULL, nc = -1) {
        cpath <- getConnectivityPath(sigdb)
        playbase::sigdb.getEnrichmentMatrix( sigdb, select=select, path=cpath,
                                             which=c("gsea","rankcor"))
    }
    
    getSignatureMatrix <- function(sigdb) {
        cpath <- getConnectivityPath(sigdb)
        playbase::sigdb.getSignatureMatrix(sigdb, path=cpath)
    }


    get_pgx_connectivity <- shiny::reactive({
      shiny::req(pgx, pgx$connectivity)
      shiny::validate(shiny::need("connectivity" %in% names(pgx), "no connectivity in object."))

      pgx.connectivity <- pgx$connectivity
      if(!"datasets-sigdb" %in% names(pgx.connectivity)) {
        warning("[getConnectivityScores] ERROR : could not get scores")
        dbg("[connectivity_server.R] computing for datasets-sigdb.h5")
        ## COMPUTE HERE???  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        sigdb.file = "/home/kwee/Playground/omicsplayground/data/datasets-sigdb.h5"
        sigdb.file = file.path(getPgxDir(),"datasets-sigdb.h5")
        user.scores <- playbase::pgx.computeConnectivityScores(
          pgx, sigdb.file, ntop = 50, contrasts = NULL,
          remove.le = TRUE, inmemory = FALSE
          )
        pgx.connectivity[["datasets-sigdb.h5"]] <- user.scores
      }
      pgx.connectivity
    })

    getConnectivityScores <- shiny::reactive({
      sigdb <- input$sigdb
      shiny::req(sigdb)
      shiny::req(get_pgx_connectivity())

      pgx.connectivity <- get_pgx_connectivity()
      dbg("[connectivity_server.R] names(pgx.connectivity) = ",names(pgx.connectivity))
      all.scores <- pgx.connectivity[[sigdb]]
      
      ct <- input$contrast
      if (!ct %in% names(all.scores)) {
        warning("[getConnectivityScores] ERROR : contrast not in connectivity scores")
        return(NULL)
      }

      scores <- as.data.frame(all.scores[[ct]])
      if (input$abs_score == FALSE) {
        ## put sign back!!!
        scores$score <- scores$score * sign(scores$rho)
      }
      scores <- scores[order(-abs(scores$score)), ]
      scores <- scores[!duplicated(scores$pathway), ]
      rownames(scores) <- scores$pathway

      if (nrow(scores) == 0 || ncol(scores) == 0) {
        warning("[getConnectivityScores] ERROR : scores has zero dimensions")
        return(NULL)
      }

      if (input$hideclustcontrasts) {
        sel <- grep("cluster[:]", scores$pathway, invert = TRUE)
        scores <- scores[sel, , drop = FALSE]
      }

      ## only those in existing database
      ##cts <- getConnectivityContrasts(sigdb)
      sigpath <- getConnectivityPath(sigdb)
      cts <- playbase::sigdb.getConnectivityContrasts(sigdb, path=sigpath)
      scores <- scores[which(rownames(scores) %in% cts), , drop = FALSE]

      ## filter on significance
      qsig <- as.numeric(input$connectivityScoreTable_qsig)      
      scores <- scores[which(scores$padj <= qsig), , drop = FALSE]
      scores <- scores[order(-scores$score), , drop = FALSE]
      
      no.le <- !("leadingEdge" %in% colnames(scores))
      abs_score <- input$abs_score
      ntop <- 100

      if (no.le && abs_score == TRUE) {
        ## recreate "leadingEdge" list
        sig <- playbase::sigdb.getSignatureMatrix(sigdb, path=sigpath)
        fc <- getCurrentContrast()$fc
        fc <- fc[order(-abs(fc))]
        fc.up <- head(names(fc[fc > 0]), ntop)
        fc.dn <- head(names(fc[fc < 0]), ntop)
        ff <- c(fc.up, fc.dn)
        e1 <- apply(sig$up, 2, function(g) intersect(ff, g))
        e2 <- apply(sig$dn, 2, function(g) intersect(ff, g))
        ee <- mapply(c, e1, e2)
        ee <- ee[match(scores$pathway, names(ee))]
        scores$leadingEdge <- ee
      }
      
      if (no.le && abs_score == FALSE) {
        ## recreate "leadingEdge" list
        sig <- getSignatureMatrix(sigdb)
        fc <- getCurrentContrast()$fc
        fc <- fc[order(-abs(fc))]

        fc.up <- head(names(fc[fc > 0]), ntop)
        fc.dn <- head(names(fc[fc < 0]), ntop)

        p1 <- apply(sig$up, 2, function(g) intersect(fc.up, g))
        p2 <- apply(sig$dn, 2, function(g) intersect(fc.dn, g))
        pp <- mapply(c, p1, p2)

        n1 <- apply(sig$up, 2, function(g) intersect(fc.dn, g))
        n2 <- apply(sig$dn, 2, function(g) intersect(fc.up, g))
        nn <- mapply(c, n1, n2)

        ee <- vector("list", nrow(scores))
        pos.rho <- which(scores$rho >= 0)
        neg.rho <- which(scores$rho < 0)
        ee[pos.rho] <- pp[match(scores$pathway[pos.rho], names(pp))]
        ee[neg.rho] <- nn[match(scores$pathway[neg.rho], names(nn))]
        scores$leadingEdge <- ee
      }
      
      ## bail out
      if (nrow(scores) == 0) {
        return(NULL)
      }
      
      return(scores)
    })

    ## ================================================================================
    ## Correlation score table
    ## ================================================================================

    getTopProfiles <- shiny::reactive({
      ## Get profiles of top-enriched contrasts (not all genes...)
      ##
      ##
      df <- getConnectivityScores()

##    ii=1:100;sigdb="sigdb-archs4.h5"
      ii <- connectivityScoreTable$rows_all()
      shiny::req(ii, input$sigdb)
      ii <- head(ii, 100) ## 50??
      pw <- df$pathway[ii]

      sigdb <- input$sigdb
      shiny::req(sigdb)

      fc <- getCurrentContrast()$fc
      ngenes <- 500
      var.genes <- head(names(sort(-abs(fc))), ngenes)
      var.genes <- unique(c(var.genes, sample(names(fc), ngenes))) ## add some random
      F <- getConnectivityMatrix(sigdb, select = pw, genes = var.genes)
      pw <- intersect(pw, colnames(F))
      F <- F[, pw, drop = FALSE]
      return(F)
    })

    ## ============================================================================
    ## FC correlation/scatter plots
    ## ============================================================================

    connectivity_plot_FCFCplots_server(
      "FCFCplots",
      pgx,
      reactive(input$contrast),
      getCurrentContrast,
      getTopProfiles,
      getConnectivityScores,
      watermark = WATERMARK
    )

    connectivityScoreTable <- connectivity_table_similarity_scores_server(
      "connectivityScoreTable",
      getConnectivityScores = getConnectivityScores,
      columns = c("pathway", "score", "rho", "NES", "padj"),
      height = "200px" ## scrollY height
    )

    ## ================================================================================
    ## Cumulative FC barplot
    ## ================================================================================

    connectivity_plot_cumFCplot_server(
      "cumFCplot",
      getTopProfiles,
      getConnectivityScores,
      getCurrentContrast
    )

    ## ================================================================================
    ## Cumulative enrichment barplot
    ## ================================================================================

    connectivity_plot_cumEnrichmentPlot_server(
      "cumEnrichmentPlot",
      pgx,
      reactive(input$sigdb),
      getConnectivityScores,
      connectivityScoreTable,
      getEnrichmentMatrix,
      getCurrentContrast,
      watermark = WATERMARK
    )


    ## =============================================================================
    ## CONNECTIVITY MAP
    ## =============================================================================
    connectivity_plot_connectivityMap_server(
      "connectivityMap",
      pgx,
      reactive(getConnectivityFilename(input$sigdb)),
      getConnectivityScores,
      getEnrichmentMatrix
    )

#   connectivityScoreTable2 <- connectivity_table_similarity_scores2_server(
#     "connectivityScoreTable2",
#     getConnectivityScores = getConnectivityScores
#   )

    connectivityScoreTable2<- connectivity_table_similarity_scores_server(
      "connectivityScoreTable2",
      getConnectivityScores = getConnectivityScores,
      columns = c("score", "pathway", "rho", "NES", "padj"),
      height = "550px"
    )

    ## -------------------------------------------------------------------------------
    ## Leading-edge graph
    ## -------------------------------------------------------------------------------

    getLeadingEdgeGraph <- connectivity_plot_leadingEdgeGraph_server(
      "leadingEdgeGraph",
      getConnectivityScores,
      connectivityScoreTable,
      getCurrentContrast,
      getTopProfiles
    )

    ## -------------------------------------------------------------------------------
    ## Enrichment graph
    ## -------------------------------------------------------------------------------

    connectivity_plot_enrichmentGraph_server(
      "enrichmentGraph",
      getLeadingEdgeGraph,
      getConnectivityScores,
      connectivityScoreTable,
      cumEnrichmentTable
    )

    ## ======================================================================
    ## Scatter
    ## ======================================================================

    ## ----------------------------------------------------------------------
    ## Scatterplot matrix in plotly
    ##
    ## From: https://plot.ly/r/splom/
    ## ----------------------------------------------------------------------

    connectivity_plot_scatterPlot_server(
      "scatterPlot",
      pgx,
      reactive(input$sigdb),
      getConnectivityContrasts,
      getCurrentContrast,
      connectivityScoreTable,
      getConnectivityScores,
      getConnectivityMatrix,
      watermark = WATERMARK
    )

    ## =============================================================================
    ## CONNECTIVITY HEATMAP
    ## =============================================================================
    connectivity_plot_connectivityHeatmap_server(
      "connectivityHeatmap",
      getTopProfiles,
      getConnectivityScores,
      getCurrentContrast
    )
  })
} ## end-of-Board
